<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Air Control - Island Edition</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        /* The linear-gradient creates a 40% black tint over the image */
        background: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)),
          url("back.jpg") no-repeat center center fixed;
        background-size: cover;
        font-family: "Arial Black", sans-serif;
        touch-action: none;
      }
      canvas {
        display: block;
      }

      #landscape-warning {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #4fa1ff;
        color: white;
        z-index: 1000;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      #landscape-warning h1 {
        font-size: 24px;
        margin-bottom: 8px;
        letter-spacing: 1px;
      }
      #landscape-warning p {
        font-size: 14px;
        opacity: 0.9;
        margin: 0;
        font-family: Arial, sans-serif;
      }

      .phone-icon {
        width: 40px;
        height: 70px;
        border: 3px solid white;
        border-radius: 6px;
        margin-bottom: 20px;
        animation: rotatePhone 2s ease-in-out infinite;
        position: relative;
      }
      .phone-icon::after {
        content: "";
        position: absolute;
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
        width: 6px;
        height: 6px;
        background: white;
        border-radius: 50%;
      }

      @keyframes rotatePhone {
        0% {
          transform: rotate(0deg);
        }
        50% {
          transform: rotate(-90deg);
        }
        100% {
          transform: rotate(-90deg);
        }
      }

      @media screen and (orientation: portrait) {
        #landscape-warning {
          display: flex !important;
        }
      }

      #home-screen {
        position: absolute;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        cursor: pointer;
      }

      h1 {
        color: white;
        font-size: clamp(40px, 10vw, 70px);
        margin: 0;
        text-shadow: 4px 4px 0px rgba(0, 0, 0, 0.15);
      }
      #plane-logo {
        width: clamp(120px, 30vw, 220px);
        height: auto;
        margin: 20px 0;
        animation: hover 3s ease-in-out infinite;
      }
      @keyframes hover {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-15px);
        }
      }
      .tap-to-play {
        color: white;
        font-size: 22px;
        margin-top: -10px;
        animation: blink 1.5s infinite;
      }

      #instruction-text {
        position: absolute;
        top: 10%;
        width: 100%;
        text-align: center;
        color: white;
        font-size: clamp(20px, 4vw, 25px);
        text-shadow: 3px 3px 10px rgba(0, 0, 0, 0.5);
        pointer-events: none;
        display: none;
        z-index: 100;
        animation: blink 0.8s infinite;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.2;
        }
      }
    </style>
  </head>
  <body>
    <div id="landscape-warning">
      <div class="phone-icon"></div>
      <h1>PLEASE ROTATE YOUR DEVICE</h1>
      <p>This game is designed for Landscape Mode.</p>
    </div>

    <div id="home-screen" onclick="startGame()">
      <h1>AIR CONTROL</h1>
      <img src="plane.png" id="plane-logo" alt="Plane Image" />
      <div class="tap-to-play">TAP TO PLAY</div>
    </div>

    <div id="instruction-text">DRAG AND LAND THE PLANE ON THE RUNWAY</div>

    <canvas id="gameCanvas"></canvas>

    <script>
      /** * CONFIGURATION */
      const BASE_SPAWN = 3000;
      const BASE_SPEED = 0.6;
      const COLLISION_DIST = 35;
      const ALERT_DIST = 85;

      const crashSfx = new Audio("crash.mp3");
      const landSfx = new Audio("land.mp3");
      const bgMusic = new Audio("game_music.mp3");
      bgMusic.loop = true;
      bgMusic.volume = 0.4;

      const runway = {
        w: 220,
        h: 40,
        gap: 80,
        hitboxRadius: 35,
      };

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const homeScreen = document.getElementById("home-screen");
      const instructionText = document.getElementById("instruction-text");

      const planeImg = new Image();
      planeImg.src = "plane.png";

      let planes = [];
      let gameActive = false;
      let selectedPlane = null;
      let gameSpeedMultiplier = 1;
      let hasStartedOnce = false;
      let animationId = null;
      let score = 0;
      let arrowOffset = 0;

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      class Plane {
        constructor() {
          this.size = 45;
          this.opacity = 1;
          this.landing = false;
          this.targetY = 0;
          this.landingDir = 1;
          this.remove = false;
          this.isAlert = false;
          this.isCrashing = false;
          this.isLocked = false;
          this.path = [];

          // Plane Logic: Random Color Type
          this.type = Math.random() > 0.5 ? "RED" : "YELLOW";
          this.glowColor = this.type === "RED" ? "#FF3333" : "#FFFF00";

          const side = Math.floor(Math.random() * 4);
          if (side === 0) {
            this.x = -60;
            this.y = Math.random() * canvas.height;
            this.angle = 0;
          } else if (side === 1) {
            this.x = canvas.width + 60;
            this.y = Math.random() * canvas.height;
            this.angle = Math.PI;
          } else if (side === 2) {
            this.x = Math.random() * canvas.width;
            this.y = -60;
            this.angle = Math.PI / 2;
          } else {
            this.x = Math.random() * canvas.width;
            this.y = canvas.height + 60;
            this.angle = -Math.PI / 2;
          }
        }

        isOnScreen() {
          return (
            this.x > 0 &&
            this.x < canvas.width &&
            this.y > 0 &&
            this.y < canvas.height
          );
        }

        update() {
          const currentSpeed = BASE_SPEED * gameSpeedMultiplier;
          if (this.landing) {
            const targetX =
              this.landingDir === 1
                ? canvas.width / 2 + 100
                : canvas.width / 2 - 100;
            this.x += (targetX - this.x) * 0.05 * gameSpeedMultiplier;
            this.y += (this.targetY - this.y) * 0.1 * gameSpeedMultiplier;
            this.angle = this.landingDir === 1 ? 0 : Math.PI;
            this.size *= 0.98;
            this.opacity -= 0.015 * gameSpeedMultiplier;
            if (this.opacity <= 0) {
              this.remove = true;
              updateScore(5); // Logging score increase
            }
            return;
          }
          if (this.path.length > 0) {
            const next = this.path[0];
            const dx = next.x - this.x;
            const dy = next.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 5) {
              this.path.shift();
              if (this.path.length === 0) this.checkManualLanding();
            } else {
              this.angle = Math.atan2(dy, dx);
              this.x += Math.cos(this.angle) * currentSpeed;
              this.y += Math.sin(this.angle) * currentSpeed;
            }
          } else {
            this.x += Math.cos(this.angle) * currentSpeed;
            this.y += Math.sin(this.angle) * currentSpeed;
          }
          if (this.x < -100) this.x = canvas.width + 80;
          if (this.x > canvas.width + 100) this.x = -80;
          if (this.y < -100) this.y = canvas.height + 80;
          if (this.y > canvas.height + 100) this.y = -80;
        }

        checkManualLanding() {
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          const r1EntryX = cx - runway.w / 2;
          const r1Y = cy - runway.gap / 2;
          const r2EntryX = cx + runway.w / 2;
          const r2Y = cy + runway.gap / 2;

          const dist1 = Math.sqrt(
            (this.x - r1EntryX) ** 2 + (this.y - r1Y) ** 2
          );
          const dist2 = Math.sqrt(
            (this.x - r2EntryX) ** 2 + (this.y - r2Y) ** 2
          );

          // Landing Logic: Only allow landing if color matches the runway
          if (dist1 < runway.hitboxRadius && this.type === "RED") {
            this.targetY = r1Y;
            this.landingDir = 1;
            this.initiateLanding();
          } else if (dist2 < runway.hitboxRadius && this.type === "YELLOW") {
            this.targetY = r2Y;
            this.landingDir = -1;
            this.initiateLanding();
          }
        }

        initiateLanding() {
          this.landing = true;
          landSfx.currentTime = 0;
          landSfx.play().catch(() => {});
        }

        draw() {
          if (this.path.length > 0 && !this.landing) {
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = this.glowColor;
            ctx.lineWidth = 3;
            ctx.moveTo(this.x, this.y);
            this.path.forEach((p) => ctx.lineTo(p.x, p.y));
            ctx.stroke();
            ctx.setLineDash([]);
          }
          ctx.save();
          ctx.globalAlpha = this.opacity;
          ctx.translate(this.x, this.y);

          // Plane Shadows based on type
          ctx.shadowBlur = 15;
          ctx.shadowColor = this.glowColor;

          if (this.isAlert && !this.landing) {
            ctx.beginPath();
            ctx.arc(
              0,
              0,
              this.size * (0.8 + Math.sin(Date.now() / 100) * 0.2),
              0,
              Math.PI * 2
            );
            ctx.strokeStyle = "rgba(255, 0, 0, 0.7)";
            ctx.lineWidth = 3;
            ctx.stroke();
          }
          ctx.rotate(this.angle + Math.PI / 2);
          if (this.isCrashing) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = "red";
            ctx.globalCompositeOperation = "source-atop";
            if (planeImg.complete)
              ctx.drawImage(
                planeImg,
                -this.size / 2,
                -this.size / 2,
                this.size,
                this.size
              );
            ctx.fillStyle = "red";
            ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
            ctx.globalCompositeOperation = "source-over";
          } else {
            if (planeImg.complete)
              ctx.drawImage(
                planeImg,
                -this.size / 2,
                -this.size / 2,
                this.size,
                this.size
              );
          }
          ctx.restore();
        }
      }

      function updateScore(points) {
        score = Math.max(0, score + points);
        // Score displayed in logs as requested
        console.log("SCORE UPDATED: " + points + " | TOTAL SCORE: " + score);
      }

      function checkCollisions() {
        planes.forEach((p) => {
          p.isAlert = false;
          p.isCrashing = false;
        });
        for (let i = 0; i < planes.length; i++) {
          for (let j = i + 1; j < planes.length; j++) {
            const p1 = planes[i];
            const p2 = planes[j];
            if (
              p1.landing ||
              p2.landing ||
              !p1.isOnScreen() ||
              !p2.isOnScreen()
            )
              continue;
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < ALERT_DIST) {
              p1.isAlert = true;
              p2.isAlert = true;
            }
            if (dist < COLLISION_DIST) {
              p1.isCrashing = true;
              p2.isCrashing = true;
              crashSfx.currentTime = 0;
              crashSfx.play().catch(() => {});
              showCrashText((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
              updateScore(-1);
              p1.x = -500;
              p2.x = canvas.width + 500;
              p1.path = [];
              p2.path = [];
            }
          }
        }
      }

      let crashTexts = [];
      function showCrashText(x, y) {
        crashTexts.push({ x, y, age: 0 });
      }

      function drawRunway() {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        ctx.save();

        // Island Base Background Layers
        ctx.beginPath();
        ctx.ellipse(cx, cy, runway.w * 1.05, runway.h * 5.0, 0, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cx, cy, runway.w * 0.95, runway.h * 4.7, 0, 0, Math.PI * 2);
        ctx.fillStyle = "#d4b375";
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cx, cy, runway.w * 0.85, runway.h * 4.4, 0, 0, Math.PI * 2);
        ctx.fillStyle = "#e3c68d";
        ctx.fill();

        // RED RUNWAY (TOP)
        const r1Y = cy - runway.gap / 2;
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(
          cx - runway.w / 2 + 5,
          r1Y - runway.h / 2 + 5,
          runway.w,
          runway.h
        );
        ctx.fillStyle = "#222";
        ctx.strokeStyle = "#FF3333";
        ctx.lineWidth = 3;
        ctx.fillRect(cx - runway.w / 2, r1Y - runway.h / 2, runway.w, runway.h);
        ctx.strokeRect(
          cx - runway.w / 2,
          r1Y - runway.h / 2,
          runway.w,
          runway.h
        );
        ctx.strokeStyle = "#fff";
        ctx.setLineDash([15, 10]);
        ctx.beginPath();
        ctx.moveTo(cx - runway.w / 2 + 20, r1Y);
        ctx.lineTo(cx + runway.w / 2 - 20, r1Y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.strokeStyle = "#FF3333";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(cx - runway.w / 2, r1Y - 15);
        ctx.lineTo(cx - runway.w / 2, r1Y + 15);
        ctx.stroke();

        // YELLOW RUNWAY (BOTTOM)
        const r2Y = cy + runway.gap / 2;
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(
          cx - runway.w / 2 + 5,
          r2Y - runway.h / 2 + 5,
          runway.w,
          runway.h
        );
        ctx.fillStyle = "#222";
        ctx.strokeStyle = "#FFFF00";
        ctx.lineWidth = 3;
        ctx.fillRect(cx - runway.w / 2, r2Y - runway.h / 2, runway.w, runway.h);
        ctx.strokeRect(
          cx - runway.w / 2,
          r2Y - runway.h / 2,
          runway.w,
          runway.h
        );
        ctx.strokeStyle = "#fff";
        ctx.setLineDash([15, 10]);
        ctx.beginPath();
        ctx.moveTo(cx - runway.w / 2 + 20, r2Y);
        ctx.lineTo(cx + runway.w / 2 - 20, r2Y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.strokeStyle = "#FFFF00";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(cx + runway.w / 2, r2Y - 15);
        ctx.lineTo(cx + runway.w / 2, r2Y + 15);
        ctx.stroke();

        // COLORED ARROWS
        arrowOffset = (Date.now() / 20) % 40;

        // Top runway Red Arrow
        ctx.fillStyle = "#FF3333";
        drawArrow(cx - runway.w / 2 - 50 + arrowOffset, r1Y, 0);

        // Bottom runway Yellow Arrow
        ctx.fillStyle = "#FFFF00";
        drawArrow(cx + runway.w / 2 + 50 - arrowOffset, r2Y, Math.PI);

        ctx.restore();
      }

      function drawArrow(x, y, angle) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(-15, -10);
        ctx.lineTo(5, 0);
        ctx.lineTo(-15, 10);
        ctx.fill();
        ctx.restore();
      }

      function spawnPlane() {
        if (!gameActive) return;
        planes.push(new Plane());
        const delay = (BASE_SPAWN + Math.random() * 2000) / gameSpeedMultiplier;
        setTimeout(spawnPlane, delay);
      }

      async function startGame() {
        if (hasStartedOnce) return;
        hasStartedOnce = true;
        bgMusic.play().catch(() => {});
        crashSfx
          .play()
          .then(() => {
            crashSfx.pause();
            crashSfx.currentTime = 0;
          })
          .catch(() => {});
        try {
          if (screen.orientation && screen.orientation.lock) {
            await screen.orientation.lock("landscape");
          }
        } catch (err) {
          console.log("Orientation lock failed.");
        }
        homeScreen.style.display = "none";
        instructionText.style.display = "block";
        setTimeout(() => {
          instructionText.style.display = "none";
        }, 4000);
        gameActive = true;
        for (let i = 0; i < 2; i++) planes.push(new Plane());
        spawnPlane();
        if (animationId) cancelAnimationFrame(animationId);
        animate();
      }

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          gameActive = false;
          bgMusic.pause();
          if (animationId) cancelAnimationFrame(animationId);
        } else {
          if (hasStartedOnce) {
            gameActive = true;
            bgMusic.play().catch(() => {});
            if (animationId) cancelAnimationFrame(animationId);
            animate();
          }
        }
      });

      function handleStart(x, y) {
        if (!gameActive) return;
        selectedPlane = planes.find(
          (p) => !p.landing && Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2) < 60
        );
        if (selectedPlane) {
          selectedPlane.path = [];
          selectedPlane.isLocked = false;
        }
      }

      function handleMove(x, y) {
        if (gameActive && selectedPlane && !selectedPlane.isLocked) {
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          const r1EntryX = cx - runway.w / 2;
          const r1Y = cy - runway.gap / 2;
          const r2EntryX = cx + runway.w / 2;
          const r2Y = cy + runway.gap / 2;

          const distR1 = Math.sqrt((x - r1EntryX) ** 2 + (y - r1Y) ** 2);
          const distR2 = Math.sqrt((x - r2EntryX) ** 2 + (y - r2Y) ** 2);

          // Match Plane Color to Runway
          if (distR1 < 35 && selectedPlane.type === "RED") {
            selectedPlane.path.push({ x: r1EntryX, y: r1Y });
            selectedPlane.isLocked = true;
            selectedPlane = null;
          } else if (distR2 < 35 && selectedPlane.type === "YELLOW") {
            selectedPlane.path.push({ x: r2EntryX, y: r2Y });
            selectedPlane.isLocked = true;
            selectedPlane = null;
          } else {
            selectedPlane.path.push({ x, y });
          }
        }
      }

      function handleEnd() {
        selectedPlane = null;
      }

      canvas.addEventListener("mousedown", (e) =>
        handleStart(e.clientX, e.clientY)
      );
      window.addEventListener("mousemove", (e) =>
        handleMove(e.clientX, e.clientY)
      );
      window.addEventListener("mouseup", handleEnd);
      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          handleStart(e.touches[0].clientX, e.touches[0].clientY);
        },
        { passive: false }
      );
      window.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          handleMove(e.touches[0].clientX, e.touches[0].clientY);
        },
        { passive: false }
      );
      window.addEventListener("touchend", handleEnd);

      function animate() {
        if (!gameActive) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRunway();
        checkCollisions();
        for (let i = planes.length - 1; i >= 0; i--) {
          const plane = planes[i];
          plane.update();
          plane.draw();
          if (plane.remove) planes.splice(i, 1);
        }
        // Crash animations (text only)
        ctx.font = "bold 35px Arial Black";
        ctx.fillStyle = "red";
        crashTexts.forEach((t, i) => {
          ctx.globalAlpha = 1 - t.age / 60;
          ctx.fillText("CRASH", t.x - 70, t.y - t.age);
          t.age++;
          if (t.age > 60) crashTexts.splice(i, 1);
        });
        ctx.globalAlpha = 1;
        animationId = requestAnimationFrame(animate);
      }
    </script>
  </body>
</html>

